// Generated by CoffeeScript 1.9.2
(function() {
  var Actor, ActorTemplate, Boombox, Brain, CAN_PLAY_AUDIO, ChangeImageStep, Character, Component, Curtain, DelayStep, FlashCurtainStep, HTMLBlock, HideImageStep, HideTextboxStep, ImageSpot, LowerCurtainStep, MarkStep, NS, Neurosurgeon, NewCurtain, PlayTrackStep, SayLineStep, Script, ScriptBuilder, ScriptMenu, ScriptMenuItem, ScriptPause, ScriptPauseMenu, ShowBlockStep, ShowMenuStep, Singleton, SpeechBubble, SplashScreen, Stage, Step, StopTrackStep, Widget, base, base1, cancelAnimationFrame, create_element, normalize_color, promise_always, promise_event, promise_transition, promise_wait, refire, requestAnimationFrame, script_from_json,
    slice = [].slice,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;

  cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame;

  if (window.console == null) {
    window.console = {};
  }

  if ((base = window.console).log == null) {
    base.log = function() {};
  }

  if ((base1 = window.console).error == null) {
    base1.error = function() {};
  }

  create_element = function(tag, attrs) {
    var el, key, value;
    if (attrs == null) {
      attrs = {};
    }
    el = document.createElement(tag);
    for (key in attrs) {
      value = attrs[key];
      el.setAttribute(key, value);
    }
    return el;
  };

  promise_always = function() {

    /*
    Return a Deferred that's already been resolved.  Mainly useful for cases
    where you want to defer an action until after a first step has been
    completed, but the first step is optional.
    
    The Deferred's value will be null.
     */
    return $.when(null);
  };

  promise_event = function($element, event, failure_event) {
    var _namespace_event, namespace, promise;
    if (failure_event == null) {
      failure_event = null;
    }

    /*
    Return a Deferred that will resolve when the named event (or
    space-separated list of event names) fires.
    
    Optionally, the Deferred will be rejected when the named failure event
    fires.
    
    Either way, the Deferred's value will be the fired event.
     */
    namespace = ".cutscene-promise-event-" + (Math.random());
    _namespace_event = function(name) {
      var part;
      return [
        (function() {
          var j, len, ref, results;
          ref = name.split(' ');
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            part = ref[j];
            results.push(part + namespace);
          }
          return results;
        })()
      ].join(' ');
    };
    event = _namespace_event(event);
    promise = $.Deferred();
    $element.one(event, function(ev) {
      return promise.resolve(ev);
    });
    if (failure_event != null) {
      failure_event = _namespace_event(failure_event);
      $element.one(failure_event, function(ev) {
        return promise.reject(ev);
      });
    }
    promise.always(function() {
      return $element.off(namespace);
    });
    return promise;
  };

  promise_transition = function($el) {
    var props;
    $el = $($el);
    props = window.getComputedStyle($el[0]);
    if (props.transitionProperty !== 'none' && props.transitionDuration !== '0s') {
      return promise_event($el, 'transitionend');
    } else {
      return promise_always();
    }
  };

  promise_wait = function(time) {

    /*
    Return a Deferred that will resolve after the specified amount of time has
    passed (in SECONDS, like Python, what do you think this is).
     */
    var promise;
    promise = $.Deferred();
    window.setTimeout((function() {
      return promise.resolve(null);
    }), time * 1000);
    return promise;
  };

  refire = function() {
    var $target, event_type, event_types, j, len, results, source;
    $target = arguments[0], source = arguments[1], event_types = 3 <= arguments.length ? slice.call(arguments, 2) : [];
    results = [];
    for (j = 0, len = event_types.length; j < len; j++) {
      event_type = event_types[j];
      results.push(source.on(event_type, function() {
        var args, event;
        event = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
        return $target.triggerHandler.apply($target, [event.type].concat(slice.call(args)));
      }));
    }
    return results;
  };

  normalize_color = function(color) {
    var d, rgb_color;
    d = document.createElement('div');
    document.body.appendChild(d);
    d.style.backgroundColor = color;
    rgb_color = window.getComputedStyle(d).backgroundColor;
    document.body.removeChild(d);
    return rgb_color;
  };

  NS = '.cutscene';

  CAN_PLAY_AUDIO = (function() {
    var dummy_audio;
    dummy_audio = document.createElement('audio');
    return dummy_audio.canPlayType && dummy_audio.canPlayType('audio/ogg; codecs="vorbis"');
  })();

  Widget = (function() {
    function Widget($parent1, $container1) {
      this.$parent = $parent1;
      this.$container = $container1;
      if (this.$parent instanceof Widget) {
        this.$parent = this.$parent.$container;
      }
      if (this.$container == null) {
        this.$container = this._create_container();
        this.$parent.append(this.$container);
      }
    }

    Widget.prototype._create_container = function() {
      throw new Error("No container passed to " + this.name + " and don't know how to make one");
    };

    Widget.prototype.on = function() {
      var args, ref;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return (ref = this.$container).on.apply(ref, args);
    };

    Widget.prototype.triggerHandler = function() {
      var args, ref;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return (ref = this.$container).triggerHandler.apply(ref, args);
    };

    return Widget;

  })();

  SplashScreen = (function(superClass) {
    extend(SplashScreen, superClass);

    function SplashScreen($parent, $container) {
      SplashScreen.__super__.constructor.call(this, $parent, $container);
      this.set_ready();
      if (CAN_PLAY_AUDIO) {
        this.$container.addClass('-state-audio-on');
      } else {
        this.$container.addClass('-state-audio-off');
      }
      this.$parent.on('stage:next', (function(_this) {
        return function(event) {
          if (!_this.$container.hasClass('-state-ready')) {
            return;
          }
          if (!_this.$container.hasClass('-active')) {
            return;
          }
          return _this.$container.removeClass('-active');
        };
      })(this));
    }

    SplashScreen.prototype.set_loading = function() {
      this.$container.removeClass('-state-ready');
      this.$container.removeClass('-state-failed');
      this.$container.addClass('-state-loading');
      return this.$container.addClass('-active');
    };

    SplashScreen.prototype.set_failed = function() {
      this.$container.removeClass('-state-loading');
      this.$container.removeClass('-state-ready');
      this.$container.addClass('-state-failed');
      return this.$container.addClass('-active');
    };

    SplashScreen.prototype.set_ready = function() {
      this.$container.removeClass('-state-loading');
      this.$container.removeClass('-state-failed');
      this.$container.addClass('-state-ready');
      return this.$container.addClass('-active');
    };

    return SplashScreen;

  })(Widget);

  ScriptMenu = (function(superClass) {
    extend(ScriptMenu, superClass);

    function ScriptMenu($parent, $container) {
      ScriptMenu.__super__.constructor.call(this, $parent, $container);
      this.items = [];
    }

    ScriptMenu.prototype._create_container = function() {
      return $('<ol>', {
        "class": 'cutscene-list'
      });
    };

    ScriptMenu.prototype.add_item = function(item) {
      this.items.push(item);
      return this.$container.append(item.$container);
    };

    return ScriptMenu;

  })(Widget);

  ScriptMenuItem = (function(superClass) {
    extend(ScriptMenuItem, superClass);

    function ScriptMenuItem($parent, $container) {
      ScriptMenuItem.__super__.constructor.call(this, $parent, $container);
    }

    ScriptMenuItem.prototype._create_container = function() {
      return $('<li>', {
        text: '...loading...'
      });
    };

    ScriptMenuItem.prototype.bind_script = function(script) {
      this.$container.text('');
      this.$container.append($('<img>', {
        src: "res/" + script.name + "/" + script.preview_img
      }));
      if (script.date) {
        this.$container.append($('<time>', {
          datetime: script.date.toISOString(),
          text: script.date.toDateString()
        }));
      }
      this.$container.append($('<h2>').text(script.title || script.name));
      if (script.subtitle) {
        this.$container.append($('<h3>').text(script.subtitle));
      }
      return this.$container.data('script-name', script.name);
    };

    ScriptMenuItem.prototype.set_failed = function() {
      return this.$container.text('failed!');
    };

    return ScriptMenuItem;

  })(Widget);

  ScriptPause = (function(superClass) {
    extend(ScriptPause, superClass);

    function ScriptPause($parent, $container) {
      ScriptPause.__super__.constructor.call(this, $parent, $container);
    }

    ScriptPause.prototype._create_container = function() {
      var el;
      el = document.createElement('div');
      el.classList.add('cutscene--pause');
      return $(el);
    };

    return ScriptPause;

  })(Widget);

  ScriptPauseMenu = (function(superClass) {
    extend(ScriptPauseMenu, superClass);

    function ScriptPauseMenu($parent, $container) {
      ScriptPauseMenu.__super__.constructor.call(this, $parent, $container);
      this.$container[0].addEventListener('click', (function(_this) {
        return function(event) {
          event.stopImmediatePropagation();
          event.preventDefault();
          return _this.$container.triggerHandler(_this.pause_event());
        };
      })(this), true);
      this.$parent.on('action:pause', (function(_this) {
        return function() {
          return _this.$container.find('.cutscene--pause-menu').addClass('-active');
        };
      })(this));
      this.$parent.on('action:unpause', (function(_this) {
        return function() {
          return _this.$container.find('.cutscene--pause-menu').removeClass('-active');
        };
      })(this));
    }

    ScriptPauseMenu.prototype._create_container = function() {
      var button, el, menu;
      el = document.createElement('div');
      el.classList.add('cutscene--pause');
      button = document.createElement('div');
      button.classList.add('cutscene--pause-button');
      button.textContent = 'âš™';
      el.appendChild(button);
      menu = document.createElement('div');
      menu.classList.add('cutscene--pause-menu');
      menu.textContent = 'P A U S E';
      el.appendChild(menu);
      return $(el);
    };

    ScriptPauseMenu.prototype.is_paused = function() {
      return this.$container.find('.cutscene--pause-menu').hasClass('-active');
    };

    ScriptPauseMenu.prototype.pause_event = function() {
      if (this.is_paused()) {
        return 'action:unpause';
      } else {
        return 'action:pause';
      }
    };

    return ScriptPauseMenu;

  })(Widget);

  Brain = (function() {
    function Brain($container1) {
      this.$container = $container1;
      this._on_keydown = bind(this._on_keydown, this);
      this.current_stage = null;
      this.loading_scripts = {};
    }

    Brain.prototype.init = function() {
      var $links, $xxx_menu, j, last_mousedown, len, link;
      $xxx_menu = this.$container.find('.cutscene-list');
      if ($xxx_menu.length) {
        $links = $xxx_menu.find('li a');
        $xxx_menu.html('');
        this.script_menu = this._build_menu($xxx_menu);
        for (j = 0, len = $links.length; j < len; j++) {
          link = $links[j];
          this.register_json(link.getAttribute('href'));
        }
      } else {
        this.script_menu = this._build_menu();
      }
      this.$container.append(this.script_menu.$container);
      this.splash = new SplashScreen(this.$container, this.$container.find('.cutscene-splash'));
      this.pause = new ScriptPauseMenu(this.$container);
      this.pause.$container.hide();
      refire(this.$container, this.pause, 'action:pause', 'action:unpause');
      this.$container.on('click' + NS, (function(_this) {
        return function(event) {
          if (event.ctrlKey || event.shiftKey || event.altKey || event.metaKey) {
            return;
          }
          if (event.target.tagName === 'A') {
            event.target.setAttribute('target', '_top');
            return;
          }
          event.preventDefault();
          return _this.$container.triggerHandler('stage:next');
        };
      })(this));
      last_mousedown = 0;
      this.$container.on('mousedown' + NS, function(event) {
        var now;
        now = Date.now();
        if (now - last_mousedown < 500) {
          event.preventDefault();
        }
        return last_mousedown = now;
      });
      $(document.body).on('keydown', this._on_keydown);
      return window.addEventListener("hashchange", function(ev) {
        return console.log(ev.oldURL, ev.newURL);
      });
    };

    Brain.prototype.start = function() {
      if (location.hash !== "") {
        return this.run(location.hash.substring(1));
      } else {
        return this.show_menu();
      }
    };

    Brain.prototype.register_json = function(url) {
      var menu_item;
      if (url in this.loading_scripts) {
        return;
      }
      menu_item = new ScriptMenuItem(this.script_menu);
      this.script_menu.add_item(menu_item);
      return this.loading_scripts[url] = $.get(url).then((function(_this) {
        return function(data) {
          var deferred, e, script;
          try {
            delete _this.loading_scripts[url];
            script = script_from_json(url, data);
            return menu_item.bind_script(script);
          } catch (_error) {
            e = _error;
            deferred = $.Deferred();
            deferred.reject(null, null, e);
            return deferred;
          }
        };
      })(this)).fail(function(xhr, reason_text, reason) {
        console.error("Failed to load " + url + ":", reason);
        return menu_item.set_failed();
      });
    };

    Brain.prototype._on_keydown = function(event) {
      var fire, key;
      if (event.altKey || event.ctrlKey || event.metaKey || event.shiftKey) {
        return;
      }
      key = event.keyCode || event.charCode;
      fire = null;
      if (key === 13) {
        fire = 'menu:accept';
      } else if (key === 19 || key === 80) {
        fire = this.pause.pause_event();
      } else if (key === 32) {
        fire = 'stage:next';
      } else if (key === 38) {
        fire = 'menu:prev';
      } else if (key === 40) {
        fire = 'menu:next';
      } else if (key === 39) {
        fire = 'stage:next';
      } else if (key === 37) {
        fire = 'stage:prev';
      }
      if (fire == null) {
        return;
      }
      this.$container.triggerHandler(fire);
      return event.preventDefault();
    };

    Brain.prototype._build_menu = function() {
      var item, name, ref, script, script_menu;
      script_menu = new ScriptMenu(this.$container);
      script_menu.on('click', 'li', (function(_this) {
        return function(event) {
          var script_name;
          script_name = $(event.currentTarget).data('script-name');
          if (!script_name) {
            return;
          }
          _this.run(script_name);
          return _this.script_menu.$container.css('display', 'none');
        };
      })(this));
      ref = Script.by_name;
      for (name in ref) {
        script = ref[name];
        item = new ScriptMenuItem(script_menu);
        item.bind_script(script);
        script_menu.add_item(item);
      }
      return script_menu;
    };

    Brain.prototype.show_menu = function() {
      return this.script_menu.$container.css('display', '');
    };

    Brain.prototype.run = function(script_name) {
      var handler, load_promise, promises, ref, script_promise, url;
      promises = [];
      if (this.current_stage != null) {
        promises.push(this.current_stage.stop());
      }
      script_promise = $.Deferred();
      script_promise.done(function(script) {
        return document.title = script.title + " - Floraverse cutscenes";
      });
      promises.push(script_promise);
      handler = (function(_this) {
        return function() {
          if (script_name in Script.by_name) {
            return script_promise.resolve(Script.by_name[script_name]);
          } else if (!Object.keys(_this.loading_scripts).length) {
            return script_promise.reject(new Error("no such script " + script_name));
          }
        };
      })(this);
      ref = this.loading_scripts;
      for (url in ref) {
        load_promise = ref[url];
        load_promise.always(handler);
      }
      handler();
      this.splash.set_loading();
      this.pause.$container.show();
      this.script_menu.$container.css('display', 'none');
      return $.when.apply($, promises).then((function(_this) {
        return function(script) {
          _this.$container.css({
            width: script.size[0],
            height: script.size[1]
          });
          _this.current_stage = new Stage(_this.$container, null, script);
          return _this.current_stage.load();
        };
      })(this)).fail((function(_this) {
        return function() {
          console.log(arguments);
          _this.splash.set_failed();
        };
      })(this)).then((function(_this) {
        return function() {
          _this.splash.set_ready();
        };
      })(this));
    };

    return Brain;

  })();

  Script = (function() {
    Script.by_name = {};

    function Script(name1, preview_img1, title1, components1, partial_steps1, initial_step1, steps, label_indices1, subtitle, date, size) {
      this.name = name1;
      this.preview_img = preview_img1;
      this.title = title1;
      this.components = components1;
      this.partial_steps = partial_steps1;
      this.initial_step = initial_step1;
      this.steps = steps;
      this.label_indices = label_indices1;
      this.subtitle = subtitle;
      this.date = date;
      this.size = size != null ? size : [800, 600];
      this.current_step = null;
      Script.by_name[this.name] = this;
    }

    Script.build = function(name, preview_img, title, cb) {
      var builder;
      builder = new ScriptBuilder(name, preview_img, title);
      cb(builder);
      return builder.finalize();
    };

    Script.expand_partial_steps = function(partial_steps, components) {
      var all_keys, dummy_event, final_steps, i, j, k, key, label_indices, last_step_is_bogus, len, len1, len2, len3, m, n, new_step, partial_step, step, step_count, val;
      all_keys = Object.keys(components);
      all_keys.push('pause');
      step = {};
      for (j = 0, len = all_keys.length; j < len; j++) {
        key = all_keys[j];
        step[key] = null;
      }
      final_steps = [step];
      last_step_is_bogus = true;
      for (k = 0, len1 = partial_steps.length; k < len1; k++) {
        partial_step = partial_steps[k];
        if (partial_step.component != null) {
          key = partial_step.component.id;
          dummy_event = [partial_step.event].concat(slice.call(partial_step.xxx_event_args()));
          if ((step[key] != null) && JSON.stringify(step[key]) !== JSON.stringify(dummy_event) && final_steps.length > 1 && JSON.stringify(step[key]) !== JSON.stringify(final_steps[final_steps.length - 2][key])) {
            console.error("WARNING: " + key + " is set to " + step[key] + " and then " + dummy_event + " with no pause in between; the first state will never appear!");
          }
          step[key] = dummy_event;
          last_step_is_bogus = false;
        }
        if (partial_step.next != null) {
          step.next = partial_step.next;
        }
        if (partial_step.mark != null) {
          step.mark = partial_step.mark;
        }
        if (partial_step.pause) {
          step.pause = partial_step.pause;
          new_step = {};
          for (key in step) {
            val = step[key];
            if ((components[key] != null) && components[key].propagate) {
              new_step[key] = val;
            }
          }
          final_steps.push(new_step);
          last_step_is_bogus = true;
          step = new_step;
        }
      }
      if (last_step_is_bogus) {
        final_steps.pop();
      }
      label_indices = {};
      step_count = final_steps.length;
      for (i = m = 0, len2 = final_steps.length; m < len2; i = ++m) {
        step = final_steps[i];
        if ('mark' in step) {
          if (step.mark in label_indices) {
            throw new Error("Can't use the same mark twice: " + step.mark);
          }
          label_indices[step.mark] = i;
        }
      }
      for (i = n = 0, len3 = final_steps.length; n < len3; i = ++n) {
        step = final_steps[i];
        if ('next' in step) {
          if (step.next === null) {
            continue;
          }
          if (!step.next in label_indices) {
            throw new Error("Can't jump to bogus mark: " + step.next);
          }
          step.next = label_indices[step.next];
        } else if (i < step_count - 1) {
          step.next = i + 1;
        }
      }
      return [final_steps, label_indices];
    };

    return Script;

  })();

  Stage = (function(superClass) {
    extend(Stage, superClass);


    /*
    The thing you play out a Script on.
    
    A Script contains a listing of abstract steps, but a Stage puts them into
    reality.  All the actual DOM puppeteering happens here.
     */

    function Stage($parent, $container, script1) {
      this.script = script1;
      Stage.__super__.constructor.call(this, $parent, $container);
      this.loaded = false;
      this._busy = false;
      this._paused = false;
      this.current_step = null;
      this.$component_elements = {};
      this.step_path = [];
    }

    Stage.prototype._create_container = function() {
      return $('<div>', {
        "class": 'cutscene--theater'
      });
    };

    Stage.prototype.load = function() {

      /*
      Set up the DOM and download resources.
      
      Returns a Deferred, which will also generate progress notifications.
       */
      var _unfinished, component, element, id, promise, promises, ref, ref1;
      promises = [];
      _unfinished = {};
      ref = this.script.components;
      for (id in ref) {
        component = ref[id];
        ref1 = component.reify(this.$container), element = ref1[0], promise = ref1[1];
        this.$component_elements[id] = element;
        promises.push(promise);
      }
      this.$parent.on("stage:next" + NS + " stage:prev" + NS + " stage:jump" + NS + " action:pause" + NS + " action:unpause" + NS, (function(_this) {
        return function() {
          var args, event, ref2;
          event = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
          if (!_this.loaded) {
            return;
          }
          return (ref2 = _this.$container).triggerHandler.apply(ref2, [event.type].concat(slice.call(args)));
        };
      })(this));
      this.$container.on('stage:next' + NS, (function(_this) {
        return function(event) {
          if (!_this._busy && !event.isDefaultPrevented()) {
            return _this.advance();
          }
        };
      })(this));
      this.$container.on('stage:prev' + NS, (function(_this) {
        return function(event) {
          if (!_this._busy && !event.isDefaultPrevented()) {
            return _this.backtrack();
          }
        };
      })(this));
      this.$container.on('stage:jump' + NS, (function(_this) {
        return function(event, label) {
          _this.step_path.push(_this.current_step);
          _this.current_step = _this.script.label_indices[label];
          return _this._update();
        };
      })(this));
      return $.when.apply($, promises).then((function(_this) {
        return function() {
          _this.loaded = true;
          return _this._update_to(_this.script.initial_step);
        };
      })(this));
    };

    Stage.prototype.advance = function() {
      var next_step;
      if (this.current_step == null) {
        this.current_step = 0;
        next_step = this.script.steps[this.current_step];
        this._update();
        return true;
      }
      next_step = this.script.steps[this.current_step].next;
      if (next_step && (0 <= next_step && next_step < this.script.steps.length)) {
        this.step_path.push(this.current_step);
        this.current_step = next_step;
        this._update();
        return true;
      } else {
        return false;
      }
    };

    Stage.prototype.backtrack = function() {
      while (this.step_path.length) {
        this.current_step = this.step_path.pop();
        if (this.script.steps[this.current_step].pause !== 'wait') {
          this._update();
          return true;
        }
      }
      return false;
    };

    Stage.prototype._update = function() {
      return this._update_to(this.script.steps[this.current_step]);
    };

    Stage.prototype._update_to = function(step) {
      var $element, args, component_state, event, id, promise, promises, ref;
      promises = [];
      ref = this.$component_elements;
      for (id in ref) {
        $element = ref[id];
        component_state = step[id];
        if (component_state != null) {
          event = component_state[0], args = 2 <= component_state.length ? slice.call(component_state, 1) : [];
        } else {
          event = 'cutscene:disable';
          args = [];
        }
        promise = $element.triggerHandler(event, args);
        if (promise != null) {
          promises.push(promise);
        }
      }
      if (promises.length) {
        this._busy = true;
        promise = $.when.apply($, promises);
        promise.done((function(_this) {
          return function() {
            return _this._busy = false;
          };
        })(this));
        promise_wait(3).then((function(_this) {
          return function() {
            if (promise.state() === "pending") {
              return _this._busy = false;
            }
          };
        })(this));
      } else {
        promise = promise_always();
      }
      if (step.pause === 'wait') {
        promise.done((function(_this) {
          return function() {
            return _this.advance();
          };
        })(this));
      }
      return promise;
    };

    Stage.prototype.stop = function() {};

    return Stage;

  })(Widget);

  Component = (function() {
    Component.prototype.propagate = true;

    Component._sequence = 0;

    Component.prototype._id_suffix = function() {
      return 'component';
    };

    function Component() {
      Component._sequence++;
      this.id = Component._sequence + "-" + (this._id_suffix());
    }

    Component.prototype.toString = function() {
      return "<" + this.constructor.name + ": " + this.id + ">";
    };

    Component.prototype.list_components = function() {
      return [this];
    };

    return Component;

  })();

  Step = (function() {
    Step.prototype.event = null;

    Step.prototype.pause = false;

    Step.prototype.next = void 0;

    function Step(component1) {
      this.component = component1;
    }

    Step.prototype.xxx_event_args = function() {
      return [];
    };

    return Step;

  })();

  MarkStep = (function(superClass) {
    extend(MarkStep, superClass);

    MarkStep.prototype.component = null;

    function MarkStep(mark) {
      this.mark = mark;
    }

    return MarkStep;

  })(Step);

  LowerCurtainStep = (function(superClass) {
    extend(LowerCurtainStep, superClass);

    function LowerCurtainStep() {
      return LowerCurtainStep.__super__.constructor.apply(this, arguments);
    }

    LowerCurtainStep.prototype.pause = 'wait';

    LowerCurtainStep.prototype.event = 'cutscene:lower';

    return LowerCurtainStep;

  })(Step);

  FlashCurtainStep = (function(superClass) {
    extend(FlashCurtainStep, superClass);

    function FlashCurtainStep() {
      return FlashCurtainStep.__super__.constructor.apply(this, arguments);
    }

    FlashCurtainStep.prototype.pause = 'wait';

    FlashCurtainStep.prototype.event = 'cutscene:flash';

    return FlashCurtainStep;

  })(Step);

  Actor = (function() {
    function Actor() {}

    Actor.prototype.interrupt_next = function() {
      return false;
    };

    return Actor;

  })();

  ActorTemplate = (function() {
    function ActorTemplate() {}

    return ActorTemplate;

  })();

  NewCurtain = (function(superClass) {
    extend(NewCurtain, superClass);

    function NewCurtain($parent) {
      this.element = create_element('div', {
        "class": 'cutscene--curtain'
      });
      $parent.append(this.element);
      this.pending = false;
    }

    NewCurtain.prototype.do_lower = function() {
      var promise;
      if (this.element.classList.contains('-lowered')) {
        return;
      }
      this.element.classList.remove('-flash');
      this.element.classList.add('-lowered');
      promise = promise_transition(this.element);
      this.pending = promise;
      return promise.then((function(_this) {
        return function() {
          return _this.pending = false;
        };
      })(this));
    };

    NewCurtain.prototype.do_flash = function() {
      var promise;
      if (this.element.classList.contains('-lowered')) {
        return;
      }
      this.element.classList.add('-flash', '-lowered');
      promise = promise_transition(this.element);
      this.pending = promise;
      return promise.then((function(_this) {
        return function() {
          _this.pending = null;
          _this.element.classList.remove('-lowered');
          return promise_transition(_this.element).then(function() {
            return _this.element.classList.remove('-flash');
          });
        };
      })(this));
    };

    NewCurtain.prototype.do_disable = function() {
      if (!this.element.classList.contains('-lowered')) {
        return;
      }
      this.element.classList.remove('-lowered');
      this.pending = null;
      return;
      return promise_event(this.element, 'transitionend');
    };

    NewCurtain.prototype.interrupt_next = function() {
      var old_promise;
      if (!this.pending || !this.element.classList.contains('-lowered')) {
        return;
      }
      old_promise = this.pending;
      old_promise.resolve(null);
      this.pending = null;
      this.element.classList.remove('-lowered');
      return true;
    };

    return NewCurtain;

  })(Actor);

  Curtain = (function(superClass) {
    extend(Curtain, superClass);

    function Curtain() {
      return Curtain.__super__.constructor.apply(this, arguments);
    }

    Curtain.prototype.propagate = false;

    Curtain.prototype._id_suffix = function() {
      return 'curtain';
    };

    Curtain.prototype.json_lower = function() {
      return new LowerCurtainStep(this);
    };

    Curtain.prototype.json_flash = function() {
      return new FlashCurtainStep(this);
    };

    Curtain.prototype.reify = function($parent) {
      var actor;
      actor = new NewCurtain($parent);
      $(actor.element).on('cutscene:lower', function() {
        return actor.do_lower();
      });
      $(actor.element).on('cutscene:flash', function() {
        return actor.do_flash();
      });
      $(actor.element).on('cutscene:disable', function() {
        return actor.do_disable();
      });
      $parent.on('stage:next' + NS, (function(_this) {
        return function(event) {
          if (actor.interrupt_next()) {
            return event.preventDefault();
          }
        };
      })(this));
      return [$(actor.element), promise_always()];
    };

    return Curtain;

  })(Component);

  SayLineStep = (function(superClass) {
    extend(SayLineStep, superClass);

    SayLineStep.prototype.event = 'cutscene:change';

    SayLineStep.prototype.pause = true;

    function SayLineStep(component, xxx_fake_speaker, text1) {
      this.xxx_fake_speaker = xxx_fake_speaker;
      this.text = text1;
      SayLineStep.__super__.constructor.call(this, component);
    }

    SayLineStep.prototype.xxx_event_args = function() {
      return [this.xxx_fake_speaker, this.text];
    };

    return SayLineStep;

  })(Step);

  HideTextboxStep = (function(superClass) {
    extend(HideTextboxStep, superClass);

    function HideTextboxStep() {
      return HideTextboxStep.__super__.constructor.apply(this, arguments);
    }

    HideTextboxStep.prototype.event = 'cutscene:hide';

    return HideTextboxStep;

  })(Step);

  ShowMenuStep = (function(superClass) {
    extend(ShowMenuStep, superClass);

    ShowMenuStep.prototype.event = 'cutscene:menu';

    ShowMenuStep.prototype.next = null;

    ShowMenuStep.prototype.pause = true;

    function ShowMenuStep(component, labels_to_captions1) {
      this.labels_to_captions = labels_to_captions1;
      ShowMenuStep.__super__.constructor.call(this, component);
    }

    ShowMenuStep.prototype.xxx_event_args = function() {
      return [this.labels_to_captions];
    };

    return ShowMenuStep;

  })(Step);

  SpeechBubble = (function(superClass) {
    extend(SpeechBubble, superClass);

    function SpeechBubble() {
      this._unpause = bind(this._unpause, this);
      this._pause = bind(this._pause, this);
      return SpeechBubble.__super__.constructor.apply(this, arguments);
    }

    SpeechBubble.JUMP_WHEN_COMPLETE = {
      sentinel: true
    };

    SpeechBubble.prototype.propagate = false;

    SpeechBubble.prototype._id_suffix = function() {
      return 'speech';
    };

    SpeechBubble.prototype.reify = function($parent) {
      var $element;
      $element = $('<div>', {
        "class": 'cutscene--speech-bubble'
      });
      $parent.append($element);
      $element.data({
        'visited-labels': {}
      });
      $element.on('cutscene:change', this._change.bind(this));
      $element.on('cutscene:menu', this._menu.bind(this));
      $element.on('cutscene:hide', this._hide.bind(this));
      $element.on('cutscene:disable', this._disable.bind(this));
      $element.on('mouseenter', 'li', this._menu_hover.bind(this));
      $element.on('click', 'li', function(event) {
        var $selected, label;
        $selected = $(this);
        label = $selected.data('label');
        if (label != null) {
          event.stopImmediatePropagation();
          $element.data('visited-labels')[label] = true;
          return $parent.triggerHandler('stage:jump', [label]);
        }
      });
      $parent.on('stage:next' + NS, (function(_this) {
        return function(event) {
          return _this._possibly_fill(event, $element);
        };
      })(this));
      $parent.on('action:pause' + NS, (function(_this) {
        return function(event) {
          return _this._pause(event, $element);
        };
      })(this));
      $parent.on('action:unpause' + NS, (function(_this) {
        return function(event) {
          return _this._unpause(event, $element);
        };
      })(this));
      $parent.on('menu:next' + NS, (function(_this) {
        return function(event) {
          return _this._menu_move(event, 1);
        };
      })(this));
      $parent.on('menu:prev' + NS, (function(_this) {
        return function(event) {
          return _this._menu_move(event, -1);
        };
      })(this));
      $parent.on('menu:accept' + NS, (function(_this) {
        return function(event) {
          var $selected, label;
          $selected = $element.find('li.-selected');
          label = $selected.data('label');
          if (label != null) {
            $element.data('visited-labels')[label] = true;
            return $parent.triggerHandler('stage:jump', [label]);
          }
        };
      })(this));
      return [$element, promise_always()];
    };

    SpeechBubble.prototype._change = function(event, speaker, text) {
      var $dialogue, $el, $old_speakers, $speaker, background_color, leave_speaker, rgb_color;
      $el = $(event.currentTarget);
      if (text === "") {
        if (speaker && speaker.position) {
          $el.attr('data-position', speaker.position);
        }
        this._hide(event);
        return;
      }
      $el.removeClass('-hidden');
      $el.attr('data-state', '');
      $dialogue = this._build_dialogue(text);
      $el.children().not('.cutscene--speaker').remove();
      $el.append($dialogue);
      $old_speakers = $el.find('.cutscene--speaker');
      if (speaker === $old_speakers.data('speaker')) {
        leave_speaker = true;
      } else {
        leave_speaker = false;
      }
      if (!leave_speaker) {
        $old_speakers.removeClass('-active');
        promise_event($old_speakers, 'transitionend').done(function() {
          return $old_speakers.remove();
        });
      }
      if (leave_speaker) {

      } else if (speaker && (speaker.name != null)) {
        rgb_color = normalize_color(speaker.color);
        background_color = rgb_color.replace(/^rgb([(].+)[)]$/, "rgba$1, 0.8)");
        $el.css({
          backgroundColor: background_color,
          color: speaker.color
        });
        $speaker = $('<div>', {
          "class": 'cutscene--speaker',
          text: speaker.name,
          css: {
            backgroundColor: speaker.color
          },
          data: {
            speaker: speaker
          }
        });
        $speaker.attr('data-position', speaker.position);
        $el.append($speaker);
        $speaker[0].offsetTop;
        $speaker.addClass('-active');
      } else {
        $el.css({
          backgroundColor: '',
          color: ''
        });
        $el.removeAttr('data-position');
      }
      if (speaker && speaker.position) {
        $el.attr('data-position', speaker.position);
      }
      this._start_scrolling($dialogue);
    };

    SpeechBubble.prototype._build_dialogue = function(text) {
      var all_letters, all_word_endings, ch, current_node, current_target, i, letter, new_parent, source, target, text_chunk;
      source = document.createElement('div');
      source.innerHTML = text;
      target = document.createDocumentFragment();
      current_node = source.firstChild;
      current_target = target;
      all_letters = [];
      all_word_endings = [];
      while (current_node) {
        if (current_node.nodeType === Node.TEXT_NODE) {
          text_chunk = current_node.nodeValue;
          i = 0;
          while (true) {
            ch = text_chunk.charAt(i);
            if (ch) {
              i++;
            } else {
              break;
            }
            if (all_letters.length && ch === " ") {
              letter = all_letters[all_letters.length - 1];
              letter.textContent += ch;
              all_word_endings.push(letter);
            } else {
              letter = document.createElement('span');
              letter.textContent = ch;
              all_letters.push(letter);
              current_target.appendChild(letter);
            }
          }
        } else if (current_node.nodeType === Node.ELEMENT_NODE) {
          new_parent = current_node.cloneNode(false);
          current_target.appendChild(new_parent);
          current_target = new_parent;
        }
        if (current_node.hasChildNodes()) {
          current_node = current_node.firstChild;
        } else {
          while (current_node && !current_node.nextSibling) {
            current_node = current_node.parentNode;
            current_target = current_target.parentNode;
            if (current_node === source) {
              current_node = null;
              break;
            }
          }
          if (current_node) {
            current_node = current_node.nextSibling;
          }
        }
      }
      $(all_letters).addClass('-hidden');
      return $('<div>', {
        "class": 'cutscene--dialogue'
      }).append(target).data({
        all_letters: all_letters
      });
    };

    SpeechBubble.prototype._next_letter = function($dialogue) {
      var $all_letters, $visible_letters, all_letters;
      all_letters = $dialogue.data('all_letters');
      $all_letters = $(all_letters);
      $visible_letters = $all_letters.not('.-hidden');
      if ($visible_letters.length) {
        return $all_letters.index($visible_letters.last()) + 1;
      } else {
        return 0;
      }
    };

    SpeechBubble.prototype._start_scrolling = function($dialogue) {

      /*
      Start scrolling the current text into view, if applicable.
      
      Returns true iff there was any text to display.
       */
      var $all_letters, all_letters, letter_index;
      if ($dialogue.data('timeout')) {
        return true;
      }
      if ('done' === $dialogue.parent().attr('data-state')) {
        return false;
      }
      all_letters = $dialogue.data('all_letters');
      $all_letters = $(all_letters);
      letter_index = this._next_letter($dialogue);
      if (letter_index >= all_letters.length) {
        $dialogue.parent().attr('data-state', 'done');
        return false;
      }
      $all_letters.addClass('-hidden');
      this._scroll($dialogue, all_letters, letter_index);
      return true;
    };

    SpeechBubble.prototype._scroll = function($dialogue, all_letters, letter_index) {
      var cb, container_bottom, next_letter_top;
      next_letter_top = all_letters[letter_index].offsetTop;
      container_bottom = $dialogue.offsetParent().height() + next_letter_top;
      $dialogue.css('margin-top', all_letters[0].offsetTop - next_letter_top);
      $dialogue.parent().attr('data-state', 'scrolling');
      cb = (function(_this) {
        return function() {
          var el, state;
          $dialogue.data({
            timeout: null
          });
          state = $dialogue.parent().attr('data-state');
          while (true) {
            el = all_letters[letter_index];
            if (!el) {
              $dialogue.parent().attr('data-state', 'done');
              return;
            }
            if (el.offsetTop + el.offsetHeight >= container_bottom) {
              $dialogue.parent().attr('data-state', 'waiting');
              return;
            }
            letter_index++;
            $(el).removeClass('-hidden');
            if (state !== 'fill') {
              break;
            }
          }
          if (el && el.textContent === "\f") {
            return $dialogue.data({
              timeout: setTimeout(cb, 500)
            });
          } else {
            return $dialogue.data({
              timeout: requestAnimationFrame(cb)
            });
          }
        };
      })(this);
      return cb();
    };

    SpeechBubble.prototype._possibly_fill = function(event, $el) {

      /*
      Called when the stage receives a "next" event.  Possibly interrupts it.
      
      1. If the text is still scrolling, fill the textbox instead of
      advancing to the next step.
      2. If the textbox is full but there's still more text to show, scroll
      down and keep going instead of advancing to the next step.
       */
      var $dialogue;
      $dialogue = $el.children('.cutscene--dialogue');
      if (!$dialogue.length) {
        return;
      }
      if ($dialogue.data('timeout')) {
        $dialogue.data({
          paused: false
        });
        $dialogue.parent().attr('data-state', 'fill');
        return event.preventDefault();
      } else if (this._start_scrolling($dialogue)) {
        return event.preventDefault();
      }
    };

    SpeechBubble.prototype._menu = function(event, labels_to_captions) {
      var $el, $menu, all_visited, caption, label, visited_labels, when_complete_label;
      $el = $(event.currentTarget);
      visited_labels = $el.data('visited-labels');
      all_visited = true;
      when_complete_label = null;
      for (label in labels_to_captions) {
        caption = labels_to_captions[label];
        if (caption === SpeechBubble.JUMP_WHEN_COMPLETE) {
          when_complete_label = label;
        } else if (!visited_labels[label]) {
          all_visited = false;
          break;
        }
      }
      if (all_visited && (when_complete_label != null)) {
        $el.parent().triggerHandler('stage:jump', [when_complete_label]);
        return;
      }
      $el.removeClass('-hidden');
      $el.empty();
      $el.css({
        backgroundColor: '',
        borderColor: ''
      });
      $menu = $('<ol>', {
        "class": 'cutscene--menu'
      });
      for (label in labels_to_captions) {
        caption = labels_to_captions[label];
        if (caption === SpeechBubble.JUMP_WHEN_COMPLETE) {
          continue;
        }
        $menu.append($('<li>', {
          text: caption,
          data: {
            label: label
          }
        }));
      }
      $menu.children().first().addClass('-selected');
      $el.append($menu);
      $menu[0].scrollTop = 0;
    };

    SpeechBubble.prototype._menu_hover = function(event) {
      var $el, $hovered;
      $el = $(event.delegateTarget);
      $hovered = $(event.currentTarget);
      $el.find('li').removeClass('-selected');
      return $hovered.addClass('-selected');
    };

    SpeechBubble.prototype._menu_move = function(event, direction) {
      var $el, $menu, $target, orig_direction, ref;
      $el = $(event.currentTarget);
      $menu = $el.find('.cutscene--menu');
      if (!$menu.length) {
        return;
      }
      $target = $menu.children('li.-selected');
      $target.removeClass('-selected');
      orig_direction = direction;
      while (direction > 0) {
        direction--;
        $target = $target.next('li');
        if (!$target.length) {
          $target = $menu.children('li').first();
        }
      }
      while (direction < 0) {
        direction++;
        $target = $target.prev('li');
        if (!$target.length) {
          $target = $menu.children('li').last();
        }
      }
      $target.addClass('-selected');

      /*
      menu_top = $menu[0].scrollTop
      item_top = $target[0].offsetTop
      menu_bottom = menu_top + $menu[0].offsetHeight
      item_bottom = item_top + $target[0].offsetHeight
      if item_bottom > menu_bottom
          $menu[0].scrollTop = item_bottom - $menu[0].offsetHeight
      if item_top < menu_top
          $menu[0].scrollTop = item_top
       */
      if (!(($menu[0].scrollTop <= (ref = $target[0].offsetTop) && ref <= $menu[0].scrollTop + $menu[0].offsetHeight - $target[0].offsetHeight))) {
        return $target[0].scrollIntoView(orig_direction < 0);
      }
    };

    SpeechBubble.prototype._hide = function(event) {
      var $el;
      $el = $(event.currentTarget);
      $el.addClass('-hidden');
      return $el.text('');
    };

    SpeechBubble.prototype._disable = function(event) {
      var $el;
      $el = $(event.currentTarget);
      return $el.text('');
    };

    SpeechBubble.prototype._pause = function(event, $el) {
      var $dialogue, timeout;
      $dialogue = $el.children('.cutscene--dialogue');
      if (!$dialogue.length) {
        return;
      }
      timeout = $dialogue.data('timeout');
      if (timeout != null) {
        return cancelAnimationFrame(timeout);
      }
    };

    SpeechBubble.prototype._unpause = function(event, $el) {
      var $dialogue, all_letters, letter_index;
      $dialogue = $el.children('.cutscene--dialogue');
      if (!$dialogue.length) {
        return;
      }
      all_letters = $dialogue.data('all_letters');
      letter_index = this._next_letter($dialogue);
      if (letter_index >= all_letters.length) {
        return;
      }
      return this._scroll($dialogue, all_letters, letter_index);
    };

    return SpeechBubble;

  })(Component);

  ChangeImageStep = (function(superClass) {
    extend(ChangeImageStep, superClass);

    ChangeImageStep.prototype.event = 'cutscene:change';

    function ChangeImageStep(component, view1, offset1) {
      this.view = view1;
      this.offset = offset1 != null ? offset1 : 0;
      ChangeImageStep.__super__.constructor.call(this, component);
    }

    ChangeImageStep.prototype.xxx_event_args = function() {
      return [this.view, this.offset];
    };

    return ChangeImageStep;

  })(Step);

  HideImageStep = (function(superClass) {
    extend(HideImageStep, superClass);

    function HideImageStep() {
      return HideImageStep.__super__.constructor.apply(this, arguments);
    }

    HideImageStep.prototype.event = 'cutscene:disable';

    return HideImageStep;

  })(Step);

  ImageSpot = (function(superClass) {
    extend(ImageSpot, superClass);

    function ImageSpot(_class, opts) {
      this["class"] = _class;
      this._advance = bind(this._advance, this);
      this._change = bind(this._change, this);
      this.views = {};
      if (opts != null) {
        this.name = opts.name, this.color = opts.color, this.position = opts.position, this.mutex = opts.mutex;
      }
      ImageSpot.__super__.constructor.apply(this, arguments);
    }

    ImageSpot.prototype._id_suffix = function() {
      return this.name;
    };

    ImageSpot.prototype.add_view = function(name, tmp_image_url) {
      return this.views[name] = [
        {
          url: tmp_image_url
        }
      ];
    };

    ImageSpot.prototype.add_animation = function(name, frames) {
      return this.views[name] = frames;
    };

    ImageSpot.prototype.json_show = function(arg1) {
      var view;
      view = arg1.view;
      if (!(view in this.views)) {
        throw new Error("No such view " + view + " for image spot " + this);
      }
      return new ChangeImageStep(this, view);
    };

    ImageSpot.prototype.json_hide = function() {
      return new HideImageStep(this);
    };

    ImageSpot.prototype.reify = function($parent) {
      var $element, $img, frame, frame_elements, frames, img_promises, j, len, ref, view_elements, view_name;
      $element = $('<div>', {
        "class": "cutscene--image-spot " + this["class"]
      });
      $parent.append($element);
      view_elements = {};
      img_promises = [];
      ref = this.views;
      for (view_name in ref) {
        frames = ref[view_name];
        view_elements[view_name] = frame_elements = [];
        for (j = 0, len = frames.length; j < len; j++) {
          frame = frames[j];
          $img = $('<img>');
          img_promises.push(promise_event($img, 'load', 'error'));
          $img.attr({
            src: frame.url
          });
          $img.data('view-name', view_name);
          $img.data('delay', frame.delay || 0);
          $element.append($img);
          frame_elements.push($img);
        }
      }
      $element.data('view-elements', view_elements);
      $element.on('cutscene:change' + NS, this._change);
      $element.on('cutscene:disable' + NS, this._disable);

      /*
      $parent.on 'stage:next' + NS, (event) =>
          $x = $element.find('.-visible')
          #$x.css 'transition-property', 'none'
          $x.css 'transition-duration', '0s'
          $x.css 'opacity', '1.0'
          if $x[0]?
              $x[0].offsetHeight
          $x.css 'opacity', ''
          $x.css 'transition-duration', ''
          #$x.css 'transition-duration', '0s'
          #$element[0].style.transitionDuration = undefined
       */
      return [$element, $.when.apply($, img_promises)];
    };

    ImageSpot.prototype._change = function(event, view_name, offset) {
      var $el, $target_child, $view_elements, active_view_name, delay, promise;
      $el = $(event.currentTarget);
      $el.removeClass('-immediate');
      $el.css({
        marginLeft: (offset || 0) + "px"
      });
      active_view_name = $el.data('active-view-name');
      if (active_view_name === view_name) {
        return;
      }
      $el.data('active-view-name', view_name);
      $view_elements = $el.data('view-elements');
      $target_child = $view_elements[view_name][0];
      if ($target_child.hasClass('-visible')) {
        return;
      }
      $el.children().removeClass('-visible');
      $target_child.addClass('-visible');
      promise = promise_transition($target_child);
      delay = $target_child.data('delay');
      if (delay) {
        setTimeout(((function(_this) {
          return function() {
            return _this._advance($el, view_name, 0);
          };
        })(this)), delay);
      }
      return promise;
    };

    ImageSpot.prototype._advance = function($el, view_name, current_index) {
      var $current, $next, $view_elements, delay, next_index;
      $view_elements = $el.data('view-elements');
      $current = $view_elements[view_name][current_index];
      next_index = (current_index + 1) % $view_elements[view_name].length;
      $next = $view_elements[view_name][next_index];
      if (!$current.hasClass('-visible')) {
        return;
      }
      $current.removeClass('-visible');
      $next.addClass('-visible');
      delay = $next.data('delay');
      if (delay) {
        return setTimeout(((function(_this) {
          return function() {
            return _this._advance($el, view_name, next_index);
          };
        })(this)), delay);
      }
    };

    ImageSpot.prototype._disable = function(event) {
      var $el, $visibles, promise, promises;
      $el = $(event.currentTarget);
      $el.addClass('-immediate');
      $visibles = $el.children('.-visible');
      if ($visibles.length) {
        promises = $visibles.map(function(ix, child) {
          return promise_transition($(child));
        });
        promise = $.when.apply($, promises);
        $visibles.removeClass('-visible');
        $el.data('active-view-name', null);
      } else {
        promise = promise_always();
      }
      return promise;
    };

    return ImageSpot;

  })(Component);

  PlayTrackStep = (function(superClass) {
    extend(PlayTrackStep, superClass);

    PlayTrackStep.prototype.event = 'cutscene:change';

    function PlayTrackStep(component, track1) {
      this.track = track1;
      PlayTrackStep.__super__.constructor.call(this, component);
    }

    PlayTrackStep.prototype.xxx_event_args = function() {
      return [this.track];
    };

    return PlayTrackStep;

  })(Step);

  StopTrackStep = (function(superClass) {
    extend(StopTrackStep, superClass);

    function StopTrackStep() {
      return StopTrackStep.__super__.constructor.apply(this, arguments);
    }

    StopTrackStep.prototype.event = 'cutscene:disable';

    return StopTrackStep;

  })(Step);

  Boombox = (function(superClass) {
    extend(Boombox, superClass);

    function Boombox() {
      this._unpause = bind(this._unpause, this);
      this._pause = bind(this._pause, this);
      this._disable = bind(this._disable, this);
      this._change = bind(this._change, this);
      this.songs = {};
      Boombox.__super__.constructor.apply(this, arguments);
    }

    Boombox.prototype._id_suffix = function() {
      return 'boombox';
    };

    Boombox.prototype.add_song = function(name, arg1) {
      var loop_, url;
      url = arg1.url, loop_ = arg1.loop_;
      if (loop_ == null) {
        loop_ = true;
      }
      return this.songs[name] = {
        url: url,
        loop_: loop_
      };
    };

    Boombox.prototype.json_play = function(arg1) {
      var track;
      track = arg1.track;
      if (!track in this.songs) {
        throw new Error("No such track " + track + " for jukebox " + this);
      }
      return new PlayTrackStep(this, track);
    };

    Boombox.prototype.json_stop = function() {
      return new StopTrackStep(this);
    };

    Boombox.prototype.reify = function($parent) {
      var $element, $player, loop_, promise, promises, ref, ref1, song_elements, song_name, url;
      $element = $('<div>', {
        "class": "cutscene--boombox"
      });
      $parent.append($element);
      if (!CAN_PLAY_AUDIO) {
        return [$element];
      }
      promises = [];
      song_elements = {};
      ref = this.songs;
      for (song_name in ref) {
        ref1 = ref[song_name], url = ref1.url, loop_ = ref1.loop_;
        $player = $('<audio>');
        promise = promise_event($player, 'canplay', 'error');
        promise = promise.then(null, (function(song_name) {
          return function() {
            console.error.apply(console, ['failed to load audio:'].concat(slice.call(arguments)));
            delete song_elements[song_name];
            return promise_always();
          };
        })(song_name));
        promises.push(promise);
        $player.attr({
          src: url,
          preload: 'auto',
          autobuffer: true,
          loop: loop_
        });
        $player.data('song-name', song_name);
        $player[0].load();
        $element.append($player);
        song_elements[song_name] = $player;
      }
      $parent.on('action:pause', (function(_this) {
        return function(event) {
          return _this._pause(event, $element);
        };
      })(this));
      $parent.on('action:unpause', (function(_this) {
        return function(event) {
          return _this._unpause(event, $element);
        };
      })(this));
      $element.data('song-elements', song_elements);
      $element.on('cutscene:change', this._change);
      $element.on('cutscene:disable', this._disable);
      return [$element, $.when.apply($, promises)];
    };

    Boombox.prototype._change = function(event, song_name) {
      var $el, $new_song, $old_song, $song_elements, old_promise, old_song_name;
      $el = $(event.currentTarget);
      old_song_name = $el.data('active-song-name');
      if (old_song_name === song_name) {
        return;
      }
      $el.data('active-song-name', song_name);
      $song_elements = $el.data('song-elements');
      $old_song = $song_elements[old_song_name];
      $new_song = $song_elements[song_name];
      if ($old_song != null) {
        old_promise = this._stop_track($old_song[0]);
      } else {
        old_promise = promise_always();
      }
      if ($new_song != null) {
        $new_song.stop(true, true);
        $new_song[0].volume = 1.0;
        $new_song[0].play();
      }
      return old_promise;
    };

    Boombox.prototype._stop_track = function(media) {

      /*
      Stop a track with a fadeout.
      
      Returns a promise that will complete when the fadeout is finished.
       */
      var original_volume;
      if (media.paused) {
        return promise_always();
      }
      original_volume = media.volume;
      return $(media).animate({
        volume: 0
      }, 'slow').promise().then(function() {
        media.pause();
        media.currentTime = 0.0;
        return media.volume = original_volume;
      });
    };

    Boombox.prototype._disable = function(event) {
      var $el, $old_song, $song_elements, old_song_name;
      $el = $(event.currentTarget);
      old_song_name = $el.data('active-song-name');
      $song_elements = $el.data('song-elements');
      $old_song = $song_elements[old_song_name];
      $el.data('active-song-name', null);
      if ($old_song != null) {
        return this._stop_track($old_song[0]);
      } else {
        return promise_always();
      }
    };

    Boombox.prototype._pause = function(event, $el) {
      var $current_song, $song_elements, current_song_name;
      current_song_name = $el.data('active-song-name');
      $song_elements = $el.data('song-elements');
      $current_song = $song_elements[current_song_name];
      if ($current_song != null) {
        return $current_song[0].pause();
      }
    };

    Boombox.prototype._unpause = function(event, $el) {
      var $current_song, $song_elements, current_song_name;
      current_song_name = $el.data('active-song-name');
      $song_elements = $el.data('song-elements');
      $current_song = $song_elements[current_song_name];
      if ($current_song != null) {
        return $current_song[0].play();
      }
    };

    return Boombox;

  })(Component);

  ShowBlockStep = (function(superClass) {
    extend(ShowBlockStep, superClass);

    function ShowBlockStep() {
      return ShowBlockStep.__super__.constructor.apply(this, arguments);
    }

    ShowBlockStep.prototype.event = 'cutscene:enable';

    ShowBlockStep.prototype.pause = true;

    return ShowBlockStep;

  })(Step);

  HTMLBlock = (function(superClass) {
    extend(HTMLBlock, superClass);

    HTMLBlock.prototype.propagate = false;

    HTMLBlock.prototype._id_suffix = function() {
      return 'html';
    };

    function HTMLBlock(markup) {
      this.markup = markup;
      HTMLBlock.__super__.constructor.apply(this, arguments);
    }

    HTMLBlock.prototype.json_show = function() {
      return new ShowBlockStep(this);
    };

    HTMLBlock.prototype.reify = function($parent) {
      var $element, $wrapper;
      $element = $('<div>', {
        "class": 'cutscene--html'
      });
      $wrapper = $('<div>', {
        "class": 'cutscene--html-wrapper'
      });
      $wrapper.html(this.markup);
      $element.append($wrapper);
      $parent.append($element);
      $element.on('cutscene:enable', (function(_this) {
        return function() {
          $element.addClass('-active');
        };
      })(this));
      $element.on('cutscene:disable', (function(_this) {
        return function() {
          $element.removeClass('-active');
        };
      })(this));
      return [$element, promise_always()];
    };

    return HTMLBlock;

  })(Component);

  DelayStep = (function(superClass) {
    extend(DelayStep, superClass);

    DelayStep.prototype.event = 'cutscene:pause';

    DelayStep.prototype.pause = 'wait';

    function DelayStep(component, delay1) {
      this.delay = delay1;
      DelayStep.__super__.constructor.call(this, component);
    }

    DelayStep.prototype.xxx_event_args = function() {
      return [this.delay];
    };

    return DelayStep;

  })(Step);

  Singleton = (function(superClass) {
    extend(Singleton, superClass);

    function Singleton() {
      return Singleton.__super__.constructor.apply(this, arguments);
    }

    Singleton.prototype.propagate = false;

    Singleton.prototype.reify = function($parent) {
      var $element;
      $element = $('<div>', {
        "class": "cutscene--singleton"
      });
      $parent.append($element);
      $element.on('cutscene:pause', function(event, delay) {
        return promise_wait(delay);
      });
      return [$element, promise_always()];
    };

    return Singleton;

  })(Component);

  ScriptBuilder = (function() {
    function ScriptBuilder(name1, preview_img1, title1) {
      this.name = name1;
      this.preview_img = preview_img1;
      this.title = title1;
      this.partial_steps = [];
      this.components = {};
      this.mutexes = {};
      this.offsets = {};
      this.curtain = this.add_component(new Curtain);
      this.backdrop = this.add_component(new ImageSpot('cutscene--backdrop'));
      this.boombox = this.add_component(new Boombox);
      this.speech = this.add_component(new SpeechBubble);
      this.root_url = "res/" + this.name + "/";
    }

    ScriptBuilder.prototype.add_component = function(component) {
      this.offsets[component.id] = 0;
      return this.components[component.id] = component;
    };

    ScriptBuilder.prototype.add_view = function(name, tmp_image_url) {
      return this.backdrop.add_view(name, this.root_url + tmp_image_url);
    };

    ScriptBuilder.prototype.add_song = function(name, tmp_audio_url, params) {
      if (params == null) {
        params = {};
      }
      params.url = this.root_url + tmp_audio_url;
      return this.boombox.add_song(name, params);
    };

    ScriptBuilder.prototype.new_character = function(opts) {
      var base2, component, mutex, poses, position, spot, tmp_image_url, view_name, view_opts;
      position = opts.position, poses = opts.poses, mutex = opts.mutex;
      spot = new ImageSpot("cutscene--imagespot-" + position, opts);
      for (view_name in poses) {
        view_opts = poses[view_name];
        tmp_image_url = view_opts;
        spot.add_view(view_name, this.root_url + tmp_image_url);
      }
      component = this.add_component(spot);
      if (mutex != null) {
        ((base2 = this.mutexes)[mutex] != null ? base2[mutex] : base2[mutex] = []).push(component);
      }
      return component;
    };

    ScriptBuilder.prototype.pause = function() {
      return this.partial_steps.push(new SayLineStep(this.speech, {}, ""));
    };

    ScriptBuilder.prototype.dim_out = function(keep_music) {
      var step;
      if (keep_music == null) {
        keep_music = false;
      }
      step = {
        pause: 'wait'
      };
      if (!keep_music) {
        this.partial_steps.push(new StopTrackStep(this.boombox));
      }
      return this.partial_steps.push(new LowerCurtainStep(this.curtain));
    };

    ScriptBuilder.prototype.transition = function(view_name) {
      if (!(view_name in this.backdrop.views)) {
        throw "No such backdrop " + view_name;
      }
      return this.partial_steps.push(new ChangeImageStep(this.backdrop, view_name));
    };

    ScriptBuilder.prototype.nobackdrop = function() {
      return this.partial_steps.push(new HideImageStep(this.backdrop));
    };

    ScriptBuilder.prototype.pose = function(image_spot, view_name, offset) {
      var j, len, other_spot, ref, results;
      if (offset == null) {
        offset = null;
      }
      if (!(view_name in image_spot.views)) {
        throw "Character " + image_spot.id + " has no pose named " + view_name;
      }
      if (offset != null) {
        this.offsets[image_spot.id] = offset;
      }
      this.partial_steps.push(new ChangeImageStep(image_spot, view_name, this.offsets[image_spot.id]));
      if (image_spot.mutex) {
        ref = this.mutexes[image_spot.mutex];
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          other_spot = ref[j];
          if (other_spot !== image_spot) {
            results.push(this.partial_steps.push(new HideImageStep(other_spot)));
          } else {
            results.push(void 0);
          }
        }
        return results;
      }
    };

    ScriptBuilder.prototype.exeunt = function() {
      var image_spot, image_spots, j, len, results;
      image_spots = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      results = [];
      for (j = 0, len = image_spots.length; j < len; j++) {
        image_spot = image_spots[j];
        results.push(this.partial_steps.push(new HideImageStep(image_spot)));
      }
      return results;
    };

    ScriptBuilder.prototype.exeunt_all = function() {
      var component, id, ref, results;
      ref = this.components;
      results = [];
      for (id in ref) {
        component = ref[id];
        if (component instanceof ImageSpot && component !== this.backdrop) {
          results.push(this.partial_steps.push(new HideImageStep(component)));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    ScriptBuilder.prototype.play = function(song_name) {
      if (!(song_name in this.boombox.songs)) {
        throw "No song named " + song_name;
      }
      return this.partial_steps.push(new PlayTrackStep(this.boombox, song_name));
    };

    ScriptBuilder.prototype.nomusic = function() {
      return this.partial_steps.push(new StopTrackStep);
    };

    ScriptBuilder.prototype.say = function(character, text) {
      if (text == null) {
        throw new Error("Psst.  Line?");
      }
      return this.partial_steps.push(new SayLineStep(this.speech, character, text));
    };

    ScriptBuilder.prototype.notext = function() {
      return this.partial_steps.push(new HideTextboxStep(this.speech));
    };

    ScriptBuilder.prototype.menu = function(labels_to_captions) {
      return this.partial_steps.push(new ShowMenuStep(this.speech, labels_to_captions));
    };

    ScriptBuilder.prototype.emote = function(character, view_name, text) {
      this.pose(character, view_name);
      return this.say(character, text);
    };

    ScriptBuilder.prototype.add_credits = function(html) {
      if (this.credits != null) {
        throw new Error("Can't have two credits blocks!");
      }
      this.credits = new HTMLBlock(html);
      return this.add_component(this.credits);
    };

    ScriptBuilder.prototype.roll_credits = function() {
      if (this.credits == null) {
        throw new Error("No credits defined; call add_credits first!");
      }
      return this.partial_steps.push(new ShowBlockStep(this.credits));
    };

    ScriptBuilder.prototype.mark = function(label) {
      return this.partial_steps.push(new MarkStep(label));
    };

    ScriptBuilder.prototype.jump = function(label) {
      var l, last_step;
      l = this.partial_steps.length;
      if (!l) {
        throw new Error("Can't jump as the first step!");
      }
      last_step = this.partial_steps[l - 1];
      if (!last_step.pause) {
        throw new Error("Can only jump after a pause");
      }
      if (last_step.next != null) {
        throw new Error("Can't jump after a step that already has a 'next'");
      }
      return last_step.next = label;
    };

    ScriptBuilder.prototype.finalize = function() {
      var final_steps, initial_step, label_indices, ref;
      ref = Script.expand_partial_steps(this.partial_steps, this.components), final_steps = ref[0], label_indices = ref[1];
      initial_step = {};
      initial_step[this.speech.id] = ['cutscene:hide'];
      initial_step[this.backdrop.id] = final_steps[0][this.backdrop.id];
      return new Script(this.name, this.preview_img, this.title, this.components, this.partial_steps, initial_step, final_steps, label_indices);
    };

    return ScriptBuilder;

  })();

  Character = (function() {
    function Character(speech1, relative_to, name, color, position, poses) {
      var args, cls, ref;
      this.speech = speech1;
      this.fake_speaker = {
        name: name,
        position: position,
        color: color != null ? color : 'black'
      };
      cls = "cutscene--imagespot-" + position;
      this.image_spot = new ImageSpot(cls);
      ref = poses != null ? poses : [];
      for (name in ref) {
        args = ref[name];
        this.image_spot.add_view(name, relative_to + args);
      }
    }

    Character.from_json = function(speech, relative_to, arg1) {
      var color, name, poses, position;
      name = arg1.name, color = arg1.color, position = arg1.position, poses = arg1.poses;
      return new Character(speech, relative_to, name, color, position, poses);
    };

    Character.prototype.list_components = function() {
      return [this.image_spot];
    };

    Character.prototype.json_say = function(arg1) {
      var text;
      text = arg1.text;
      if (text == null) {
        throw "Need some text!";
      }
      return new SayLineStep(this.speech, this.fake_speaker, text);
    };

    Character.prototype.json_pose = function(args) {
      return this.image_spot.json_show(args);
    };

    Character.prototype.json_leave = function() {
      return new HideImageStep(this.image_spot);
    };

    return Character;

  })();

  script_from_json = function(url, data) {
    var action, actor, actordef, actors, arg, args, component, component_id, components, contributor, credits, credits_html, devart, e, event, final_steps, handle, initial_step, instruction, j, k, label_indices, last_slash, len, len1, len2, len3, line, link, m, n, name, obj, parent, partial_steps, ref, ref1, ref10, ref11, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, relative_to, row, singleton, speech, step_obj, tumblr, twitter, who;
    components = {};
    actors = {};
    if (-1 !== data.asset_root.search(/^(?:[\/]|\w+:[\/][\/])/)) {
      relative_to = data.asset_root;
    } else {
      last_slash = url.lastIndexOf('/');
      if (last_slash === -1) {
        parent = './';
      } else {
        parent = url.substring(0, last_slash + 1);
      }
      relative_to = parent + data.asset_root;
    }
    if (relative_to.substring(-2) === "/.") {
      relative_to = relative_to.substring(0, relative_to.length - 1);
    } else if (relative_to.substring(-1) !== "/") {
      relative_to += "/";
    }
    speech = new SpeechBubble;
    components[speech.id] = speech;
    singleton = new Singleton;
    components[singleton.id] = singleton;
    if (data.credits != null) {
      credits_html = $('<div>');
      ref1 = (ref = data.credits.people) != null ? ref : [];
      for (j = 0, len = ref1.length; j < len; j++) {
        contributor = ref1[j];
        row = $('<div>', {
          "class": 'cutscene--credits-row'
        });
        credits_html.append(row);
        row.append($('<div>', {
          "class": '-for',
          text: contributor["for"]
        }));
        who = $('<div>', {
          "class": '-who'
        }).appendTo(row);
        if (contributor.website) {
          who.append($('<a>', {
            href: contributor.website,
            text: contributor.who
          }));
        } else {
          who.text(contributor.who);
        }
        devart = $('<div>', {
          "class": '-deviantart'
        }).appendTo(row);
        if (contributor.deviantart) {
          link = $('<a>', {
            href: "http://" + contributor.deviantart + ".deviantart.com/"
          });
          link.append($('<img>', {
            src: "img/deviantart.png",
            alt: "deviantArt"
          }));
          devart.append(link);
        }
        tumblr = $('<div>', {
          "class": '-tumblr'
        }).appendTo(row);
        if (contributor.tumblr) {
          link = $('<a>', {
            href: "http://" + contributor.tumblr + ".tumblr.com/"
          });
          link.append($('<img>', {
            src: "img/tumblr.png",
            alt: "Tumblr"
          }));
          tumblr.append(link);
        }
        twitter = $('<div>', {
          "class": '-twitter'
        }).appendTo(row);
        if (contributor.twitter) {
          link = $('<a>', {
            href: "https://twitter.com/" + contributor.twitter
          });
          link.append($('<img>', {
            src: "img/twitter.png",
            alt: "Twitter"
          }));
          twitter.append(link);
        }
      }
      ref3 = (ref2 = data.credits.footer_html) != null ? ref2 : [];
      for (k = 0, len1 = ref3.length; k < len1; k++) {
        line = ref3[k];
        credits_html.append($('<p>', {
          html: line
        }));
      }
      credits = new HTMLBlock(credits_html.html());
      components[credits.id] = credits;
    } else {
      credits = null;
    }
    ref4 = data.actors;
    for (handle in ref4) {
      actordef = ref4[handle];
      if (actordef.type === "character") {
        actor = Character.from_json(speech, relative_to, actordef);
      } else if (actordef.type === "spot") {
        actor = new ImageSpot("cutscene--" + actordef.position);
        ref5 = actordef.views;
        for (name in ref5) {
          args = ref5[name];
          if (typeof args === "object" && Object.getPrototypeOf(args) === Array.prototype) {
            actor.add_animation(name, (function() {
              var len2, m, results;
              results = [];
              for (m = 0, len2 = args.length; m < len2; m++) {
                arg = args[m];
                results.push({
                  url: relative_to + arg.url,
                  delay: arg.delay
                });
              }
              return results;
            })());
          } else {
            actor.add_view(name, relative_to + args);
          }
        }
      } else if (actordef.type === "jukebox") {
        actor = new Boombox;
        ref6 = actordef.tracks;
        for (name in ref6) {
          args = ref6[name];
          actor.add_song(name, {
            url: relative_to + args
          });
        }
      } else if (actordef.type === "curtain") {
        actor = new Curtain;
      }
      actors[handle] = actor;
      ref7 = actor.list_components();
      for (m = 0, len2 = ref7.length; m < len2; m++) {
        component = ref7[m];
        components[component.id] = component;
      }
    }
    partial_steps = [];
    ref8 = data.script;
    for (n = 0, len3 = ref8.length; n < len3; n++) {
      instruction = ref8[n];
      if (instruction.action === 'pause') {
        partial_steps.push(new SayLineStep(speech, {}, ""));
        continue;
      } else if (instruction.action === 'roll_credits') {
        if (credits == null) {
          throw "Can't roll credits; you never defined any!";
        }
        partial_steps.push(new ShowBlockStep(credits));
        continue;
      } else if (instruction.action === 'notext') {
        partial_steps.push(new HideTextboxStep(speech));
        continue;
      } else if (instruction.action === 'delay') {
        partial_steps.push(new DelayStep(singleton, instruction.delay));
        continue;
      }
      actor = actors[instruction.actor];
      if (actor == null) {
        throw "No such actor " + instruction.actor;
      }
      action = actor['json_' + instruction.action];
      if (action == null) {
        throw "No such action " + instruction.action + " for actor " + instruction.actor + " (" + actor + ")";
      }
      try {
        step_obj = action.call(actor, instruction);
      } catch (_error) {
        e = _error;
        console.error(e, "instruction was:", instruction);
        throw e;
      }
      partial_steps.push(step_obj);
    }
    ref9 = Script.expand_partial_steps(partial_steps, components), final_steps = ref9[0], label_indices = ref9[1];
    initial_step = (
      obj = {},
      obj["" + speech.id] = ['cutscene:hide'],
      obj
    );
    if (final_steps[0] != null) {
      ref10 = final_steps[0];
      for (component_id in ref10) {
        event = ref10[component_id];
        component = components[component_id];
        if (component instanceof ImageSpot && (component["class"] != null) && component["class"].match(/backdrop/)) {
          initial_step[component_id] = event;
        }
      }
    }
    return new Script(data.name, data.preview, data.title, components, partial_steps, initial_step, final_steps, label_indices, data.subtitle, (data.date != null ? new Date(data.date) : null), (ref11 = data.size) != null ? ref11 : null);
  };

  Neurosurgeon = (function() {
    function Neurosurgeon() {}

    Neurosurgeon.prototype.init = function() {};

    return Neurosurgeon;

  })();

  $(function() {
    var brain;
    brain = new Brain($('#cutscene-container'));
    brain.init();
    return brain.start();
  });

  this.start_editor = function(sel) {
    var $editor, j, len, li, list, proto, ref, rgb_color, script, step;
    $editor = $(sel);
    list = $('<ol>', {
      "class": 'cutscene-editor--script'
    });
    script = Script.by_name['prompt1-chefs'];
    ref = script.partial_steps;
    for (j = 0, len = ref.length; j < len; j++) {
      step = ref[j];
      li = $('<li>');
      list.append(li);
      proto = Object.getPrototypeOf(step);
      if (proto.constructor === SayLineStep) {
        if (step.xxx_fake_speaker != null) {
          li[0].style.borderColor = step.xxx_fake_speaker.color;
          rgb_color = normalize_color(step.xxx_fake_speaker.color);
          li[0].style.backgroundColor = rgb_color;
          li.append($('<div>', {
            text: step.xxx_fake_speaker.name,
            "class": '-speaker'
          }));
        }
        li.append($('<div>', {
          text: step.text,
          "class": '-line'
        }));
      } else {
        li.text(proto.constructor.name + " :: " + (step.xxx_event_args().join(' / ')));
      }
    }
    return $editor.append(list);
  };

  this.cutscene = {
    Script: Script,
    SpeechBubble: SpeechBubble,
    ImageSpot: ImageSpot
  };

}).call(this);

//# sourceMappingURL=all-temp.js.map
